是什么：
数据结构指的是“一组数据的存储结构”，算法指的是“操作数据的一组方法”。
数据结构是为算法服务的，算法是要作用再特定的数据结构上的。

学什么：

1：效率和资源消耗的度量衡--复杂度分析。

2：最常用、最基础的20个数据结构与算法，学习他们的：“来历”、“特点”、“适合解决什么问题”和“实际的应用场景”。
3：数据结构：数组、链表、栈、队列、散列表、二叉树‘、堆、跳表、图、Tire树
算法： 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

怎么学

1:边学边练，每周花 1~2 小时集中攻关三节课涉及的数据结构和算法，全部写出来。

2:主动提问、多思考、多互动。在留言区增加自己的留言。

3:自我激励，每次学习完做一篇学习笔记。

4:沉下心不要浮躁，先把这些基础的数据结构和算法，还有学习方法熟练掌握后，再追求更高层次。

flag：每篇文章必写学习笔记，每周必实现一次该周代码。



-----------------------------------------------------------------------------------------------------------------------------------------------------------

# 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？



1：怎么衡量算法代码的执行效率？

​		时间、空间复杂度分析



2：为什么需要复杂度分析？

​		1：事后统计法的测试结果非常依赖环境。

​		2：测试结果受数据规模大小影响很大

​		**3：我们要做到不需要具体的测数据来测试，就可以粗略的估计算法的执行效率**



**3：大O复杂度表示法**

​		

```java

 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

上述代码中，大意是求1,2,3,4...n 的累加和，总共分为三个运行步骤，**读数据 - 运算 - 写数据**，假设每行代码执行时间都是一样的。

第2、3行代码**每一行**运行时间为一个单位时间（unit_time），表示为 1 个 unit_time。

第4、5行代码是在重复的运行 n 次，假设每一行代码所需要 1 个 unit_time，那么4、5行代码就可以表示为

2n*unit_time。

第7行的代码也算作为 1 个unit_time的运行时间 表示为 1 unit_time。

最终我们得到这段代码的运行总时间为：**(2n + 2) * unit_time**

可以看出，**所有代码的执行时间 T(n) 与每行代码的执行次数成正比。**

​		**<u>执行的行数越多，执行次数越多，耗费时间越多。</u>**

​	



```java

 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```



按照上面的思路，我们可以看出，这个代码比上面那个的复杂。

但是，可以按照上面代码分析的思路进行分析。

假设2、3、4行代码**每一行**执行需要 1 个 unit_time，表示为 1 * unit_time

4、5行代码执行需要两个 unit_time，但是要循环 n 遍，可以表示为 2n * unit_time

5、6行代码是4行每循环一次就循环n次，简单计算下n * n 可得出 n² ，表示为 2n² * unit_time

总运行时间为：**(3 + 2n + 2n²) * unit_time**

套入刚才的表达式为：

​	**T(n) = (3 +2n + 2n²) * unit_time**



虽然我们还不知道 unit_time的值，但是可以得到一个很重要的规律：

​		**所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。**

这个规律总结起来，就是我们的 **大O复杂度表示法**

​	![大O复杂度表示法](D:\Exec\数据结构和算法\大O复杂度表示法.png)



T(n) 代表：所有代码执行所需要的总时间

n 代表：数据规模的大小

f(n)表示每行代码执行的次数总和

O表示代码的执行时间 T(n) 和 f(n) 表达式成正比



**大O时间复杂度表示法：**

第一个例子的表达式：T(n) = (2 + 2n) * unit_time 就可以表示为 ：T(n) = O(2 + 2n)

第二个例子的表达式：T(n) = (3 + 2n + 2n²) * unit_time 表示为：T(n) = O(3 + 2n + 2n²)

总结：

​	大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随着数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**。



**tip:**

​	当 n 很大，比如10000,100000时，公式中的低阶，常量，系数三部分并不左右增长趋势，都可以忽略。我们只需要记录一个最大量级就可以了，如果用大O表示法表示刚刚那两段代码的**时间复杂度**，可以表示为：

​	T(n) = O(n)		T(n) = O(n²)。



#### 怎么对一段代码进行时间复杂度分析？

​	**1：只关注循环次数最多的一段代码**

​		1：忽略代码的**常量、低阶、系数**，只关注**最大阶的量级**就可以了

​		2：**关注循环执行次数最多的那一段代码即可**

​		示例：

```java

 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

​	2、3行代码都是常量级的执行时间，与 n 的大小无关（数据规模），所以对时间复杂度没有影响。<u>（忽略）</u>

​	4、5行代码是循环次数最多的代码，这块代码要重点分析，这段代码被执行了 n 次，T(n) = O(n)

​	

**2：加法法则：总复杂度等于量级最大那段代码的复杂度**

​	

```java

int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
```

​		大意为：求 sum_1、sum_2、sum_3的和。

第一个for循环 p 是一个已知数字，100。只要是一个已知的数字，就跟 n 无关。当 n 无限大的时候，可以忽略。因为它本身对增长趋势没有影响。

第二个for循环 可以表示为 O(n)

第三个双层 for循环可以表示为 O(n²)

结合这三段代码的时间复杂度，我们取量级最大的来分析，证段代码中时间复杂度为：O(n²)

最终可表示逻辑为：

​	**T1(n) = O(f(n))**

​	**T2(n) = O(g(n))**

​	**T(n) = T1(n) + T2(n) = max( O(f(n)) , O(g(n)) )** = **O( max( f(n) , g(n) ) )** 			乘法分配律。。。不像加法啊。



**3：乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

**T1(n) = O(f(n))**

**T2(n) = O(g(n))**

**T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O( (f(n)) * g(f(n)) )**

```java

int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```

**T(n) = T1(n) * T2(n) = O(n²)**



#### 几种常见时间复杂度实例分析

![几种常见时间复杂度实例分析](D:\Exec\数据结构和算法\几种常见时间复杂度实例分析.jpg)

**多项式量级和非多项式量级。**其中，非多项式量级只有两个：**O(2n)** 和 **O(n!**)。